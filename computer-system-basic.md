# 计算机系统基础

## 1. 计算机系统概述

待补充...

-----



## 2. 数据的表示和存储

### 2.1. 数制和编码

- 一般来说，数据有多种不同的表示形式。在计算机内部所有的信息都是用二进制来进行编码，但二进制编码的表示太过于麻烦和冗余，所以我们大多数时候使用十六进制编码来代替二进制编码。
- 对于不同进制的数据，其表示形式其实大抵相同。都有自己的基数以及权值。在R进制中，其运算原则就是“逢R进一”。

### 2.2 定点数的编码表示

- 原码：最高位作为符号位，其余位表示真值的绝对值。

- 反码、补码：略。

- ==移码（待补充）==：把补码的符号位取反，通常用浮点数数值的二进制表示中。

- **补码的定义**：对于X，假定补码有n位，则：[X]~补~ = 2^n^ + X (-2^n^ <= X < 2^n^， mod 2^n^)。![image-20201213165555554](assets/image-20201213165555554.png)

  

- ![image-20201213134800786](assets/image-20201213134800786.png)

- 根据上述给定的补码的定义，看下面的例题：![image-20201213135133995](assets/image-20201213135133995.png)

  所以正数的补码就是其本身，负数的补码相当于其对应的正数补码**各位取反、末位加一**。

- 另外，如何求补码的真值呢？有以下定义：![image-20201213135552845](assets/image-20201213135552845.png)

  相当于最高位字符取反，其余各位取正然后相加即可。

### 2.3 C语言中的整数

- C语言支持的数据类型![image-20201213140042218](assets/image-20201213140042218.png)

- 由上图可知整数类型分为无符号整数和带符号整数。

- 对于无符号整数来说，其整数编码中不存在符号位，通常用来表示正数运算，例如地址运算、编号等等；

- 有符号整数不同于无符号整数，其有响应的表示正负的符号位，通常有三种定点编码表示：原码/移码/补码。

- 对于C语言中同时处理带符号整数和无符号整数，C编译器会把带符号整数强制转换为无符号整数，这也就牵扯到了两种数制中的比较，如图所示：![image-20201213141056915](assets/image-20201213141056915.png)通过观察上图所示结果，可以发现其结果与常规有一点差异。由于在比较两种整数时C编译器会把带符号整数强制转化为无符号整数，所以在比较时需要先把带符号整数的补码形式表示出来，然后将其转换为无符号形式，再比较大小。（另外，如果无符号整数被强制转换成为了带符号整数，例如上图中倒数第三行，则需要比较两者带符号形式的大小）

- 编译器中有C90和C99两种标准，两种标准如下：![image-20201213141919162](assets/image-20201213141919162.png)

  Ex：![image-20201213142212866](assets/image-20201213142212866.png)

  

  将上述结论写入C代码中进行测试并在C90上进行运算，可以发现结果为：

  ![image-20201213145037451](assets/image-20201213145037451.png)

  

```c
#include<stdio.h>

int main(int argc, char const *argv[])
{
    int x = -1;
    unsigned u = 2147483648;

    printf("x = %u = %d\n", x, x);
    printf("u = %u = %d\n", u, u);

    if (-2147483648 < 2147483647) 
    {
        printf("-2147483648 < 2147483647 is true\n");
    }
    else
    {
        printf("-2147483648 < 2147483647 is false\n");
    }

    if (-2147483648 - 1 < 2147483647)
    {
        printf("2147483648 - 1 < 2147483647\n");
    }
    else if (-2147483648 - 1 == 2147483647)
    {
        printf("2147483648 - 1 = 2147483647\n");
    }
    else
    {
        printf("2147483648 - 1 > 2147483647\n");
    }

    return 0;
}
```

但是在C99上运行结果则为：

![image-20201213145309271](assets/image-20201213145309271.png)

这是因为在C99中他们全部变成了有符号数字，所以在比较时就与常规一样，比较符合常识。

### 2.4 浮点数的编码表示

- IEEE 754标准中规格化数的表示：![image-20201213174410639](assets/image-20201213174410639.png)

  由上图可以得知，IEEE 754标准规定了对于单精度的浮点数，其有1位S表示正负，8位阶码和23位的尾数。其实阶码就是移码，但此时的阶码与之前定义的移码并不相同（参见2.2）。对于IEEE 754中，单精度浮点数阶码的偏移值为127，那么为什么不使用128呢？详见[为什么用移码来表示阶码](https://www.cnblogs.com/roscangjie/p/12237725.html)。

- Ex：![image-20201213174952824](assets/image-20201213174952824.png)

  ![image-20201213175008981](assets/image-20201213175008981.png)

- IEEE 754中特殊数的表示：

  ![image-20201213175159818](assets/image-20201213175159818.png)

  ![image-20201213175209424](assets/image-20201213175209424.png)

  ![image-20201213175226924](assets/image-20201213175226924.png)

  ![image-20201213175316630](assets/image-20201213175316630.png)

### 2.5 非数值数据的编码

- > [PPT](https://www.icourse163.org/learn/NJU-1001625001?tid=1460891441#/learn/content?type=detail&id=1237325735&cid=1257246662)

### 2.6 数据宽度和存储容量的单位

- ![image-20201213185204090](assets/image-20201213185204090.png)

- ***“字”与“字长”概念不相同！*** “字”指被处理信息的单位，用来度量数据类型的宽度。“字长”一般指数据通路的宽度，它等于CPU内部总线的宽度、GR的宽度。![image-20201213185441232](assets/image-20201213185441232.png)

- ![image-20201213185454838](assets/image-20201213185454838.png)

  > **注：容量中的K与带宽中的k不一样，一个表示2^10^，一个表示10^3^。对于如何区分它们，只需要具体情况具体分析。**

- ![image-20201213185706817](assets/image-20201213185706817.png)

  > 对于不同字长的机器，其数据类型的长度可能会有所不同。

### 2.7 数据存储时的字节排列

- 80年代后，几乎所有计算机都采用字节编址。对于不同的数据类型，其占用的存储单元也可能不同，考虑一个问题：变量地址是其最大地址还是最小地址？多个字节在存储单元中存放的顺序如何？

- 数据的排列顺序一般有两种：大端方式和小端方式。其中大端方式就是MSB在地址首部，LSB在地址尾部；小端方式则与其相反。Ex：![image-20201213193351544](assets/image-20201213193351544.png)

  ![image-20201213193416002](assets/image-20201213193416002.png)

  -----

  ## 3. 运算电路基础

  

