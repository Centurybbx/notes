# 操作系统

## 1. 操作系统概述

## 2. 进程

### 2.1 进程调度

### 2.2 进程同步、互斥

- **进程同步、互斥的基本概念：**![image-20201215215816398](assets/image-20201215215816398.png)

  其中**四个原则**需要理解并记忆。

- **进程互斥的软件实现方法：**

  - 单标志法
  - 双标志先检查法
  - 双标志后检查法
  - Peterson算法

  [四种算法的具体实现](https://www.bilibili.com/video/BV1YE411D7nH?p=19)

  

![image-20201215220406880](assets/image-20201215220406880.png)

上图是四种算法的比较。

- **[进程互斥的硬件实现方法](https://www.bilibili.com/video/BV1YE411D7nH?p=20)**

- **信号量机制：**

  之前的四种进程互斥的软件实现都没有实现“**让权等待**”，为此开始讨论信号量机制。

  用户进程通过使用OS提供的一对原语对信号量进行操作。原语其执行只能一气呵成，不可被中断。其中的阻塞原语wait成为P操作，唤醒原语成为V操作。

  - 整型信号量
  - 记录型信号量

![image-20201215222456752](assets/image-20201215222456752.png)

- **信号量实现进程互斥、同步问题:**

  - 信号量实现互斥

  ![image-20201215223409078](assets/image-20201215223409078.png)

  互斥信号量初值设置为1，是因为要想实现不同进城互斥访问临界区共享资源，那么首先要让一个进程实现P操作，此时其他进程不在拥有访问临界区的权利，在当前进程访问结束后再进行V操作即完成了对临界区的一次互斥访问。

  - 信号量实现同步

  ![image-20201215223530511](assets/image-20201215223530511.png)

  同步信号量初值设置为0，是因为同步操作是有前后顺序的，然后操作系统调度通常是异步进行的，为了规定前后才使用同步信号量。比如对于单生产者-单消费者模型：消费者必须在生产者生产后才可以消费，也就是说必须使得同步信号量大于0才能被消费者实现P操作，所以必须在生产者生产后实现一个V操作。

  - 信号量实现前驱关系

  ![image-20201215224540535](assets/image-20201215224540535.png)

- **生产者消费者模型：**

  ![image-20201216134233748](assets/image-20201216134233748.png)
  
  但对于生产者消费者模型，其中对重要的就是如何定义互斥信号量和同步信号量。通过分析此问题，我们可以发现两个对象之间对缓冲区需要进行互斥访问，但同时也需要满足“生产-消费”的同步关系。
  
- **多生产者多消费者模型：**

  具体例子就是父亲母亲和儿子女儿的水果问题，[详见](https://www.bilibili.com/video/BV1YE411D7nH?p=24)。

  ![image-20201220110218715](assets/image-20201220110218715.png)

- **单生产者多消费者模型：**

  具体例子就是[吸烟者问题](https://www.bilibili.com/video/BV1YE411D7nH?p=25)

  ![image-20201220110143073](assets/image-20201220110143073.png)

- **读者-写者问题/哲学家进餐问题：**见王道视频。

- **管程：**![image-20201220111643409](assets/image-20201220111643409.png)

### 2.3 死锁

#### 死锁的基本概念



- **死锁、饥饿、死循环的定义及其区别：**

![image-20201220140854401](assets/image-20201220140854401.png)

- **死锁产生的必要条件：**

  ![image-20201220140940649](assets/image-20201220140940649.png)死锁的产生必须遵循上图表示的四个条件，缺一不可！

- **死锁的处理策略：**

![image-20201220141142910](assets/image-20201220141142910.png)

- **死锁总结：**

![image-20201220141212295](assets/image-20201220141212295.png)

#### 预防死锁

- 由上可知，死锁的产生必须要满足四个条件，如果想要预防死锁的产生，那么我们可以破坏死锁的四个条件，具体如下：

![image-20201220141608247](assets/image-20201220141608247.png)

![image-20201220141646472](assets/image-20201220141646472.png)

![image-20201220141717690](assets/image-20201220141717690.png)

![image-20201220141752652](assets/image-20201220141752652.png)

- **总结：**

![image-20201220141809640](assets/image-20201220141809640.png)

​	主要是对内容进行理解和记忆。

#### 避免死锁

- **安全序列、不安全状态与死锁：**

![image-20201220142011636](assets/image-20201220142011636.png)

> 牢记一句话：如果系统处于安全状态，就一定不会发生死锁，但是如果系统进入不安全状态，那么它就有可能发生死锁。

- **银行家算法：**

![image-20201220142207071](assets/image-20201220142207071.png)

​	银行家算法是***重点***，其核心思想还是考虑给进程分配资源时是否会进入不安全状态，通过判断进而进行操作。

> 在对银行家算法进行做题（手算）时，我们需要往最坏的方向去想。所有的假设条件都是基于最坏的情况来定，如果最坏的情况都可以保证安全序列，那就代表系统进入了安全状态。

![image-20201220142624449](assets/image-20201220142624449.png)

上图即银行家算法的流程。

- **总结：**

![image-20201220142711972](assets/image-20201220142711972.png)

#### 死锁的检测和解除

- **死锁的检测：**

  ![image-20201220142825234](assets/image-20201220142825234.png)

![image-20201220142936610](assets/image-20201220142936610.png)

![image-20201220142956771](assets/image-20201220142956771.png)

​		死锁的检测是本节的重点，应当熟悉如何检测死锁。

- 死锁的解除

![image-20201220143109543](assets/image-20201220143109543.png)

- **总结：**

![image-20201220143126506](assets/image-20201220143126506.png)

## 3. 内存管理

### 3.1.1 内存的基本知识

- **内存/存储单元的定义：**

![image-20201221132050977](assets/image-20201221132050977.png)

- **指令：**

![image-20201221132210930](assets/image-20201221132210930.png)

- **逻辑地址和物理地址：**

![image-20201221132355134](assets/image-20201221132355134.png)

​		逻辑地址相当于相对地址，不代表真正的地址；而物理地址则是实打实的地址。

- **程序的编译、链接、装入过程：**

![image-20201221132540219](assets/image-20201221132540219.png)

> 其中在装入的过程中有三种方式：绝对装入、静态重定位、动态重定位。

- **绝对装入：**

![image-20201221132723116](assets/image-20201221132723116.png)

​		绝对装入就是直接将程序的物理地址指定出来，进而将程序存放到指定的地址当中去。

- **静态重定位：**

![image-20201221132927246](assets/image-20201221132927246.png)

​		**静态重定位**相当于计算机组成中的基址寻址方式（个人认为）。

- **动态重定位：**

![image-20201221133344408](assets/image-20201221133344408.png)

​		**动态重定位**相比于静态重定位其好处在于它在运行时才将逻辑地址转换为物理地址，并且当程序发生移动时它的物理地址可以根据重定位寄存器的值而相应地进行变化，但静态重定位仅仅可以在一开始装入时就将逻辑地址转化为物理地址，当程序移动时会发生错误。

- **总结：**

![image-20201221133826477](assets/image-20201221133826477.png)

### 3.1.2 内存管理的概念

- **知识总览：**

![image-20201221134034273](assets/image-20201221134034273.png)



![image-20201221134144704](assets/image-20201221134144704.png)

- **总结：**

![image-20201221134235198](assets/image-20201221134235198.png)

​		具体的介绍详见[视频](https://www.bilibili.com/video/BV1YE411D7nH?p=34)，不再赘述。

### 3.1.3 覆盖与交换

- **覆盖：**

<img src="assets/image-20201221134553728.png" alt="image-20201221134553728"  />

Ex:

![image-20201221134943424](assets/image-20201221134943424.png)

​		由上图，由于B、C以及D、E、F均为互斥关系，也就是在目标层只会调用其中的一部分。为了解决内存问题，使用覆盖技术可以解决一定的问题。

- **交换：**

![image-20201221135234176](assets/image-20201221135234176.png)

![image-20201221140254305](assets/image-20201221140254305.png)

- **总结：**

![image-20201221140358663](assets/image-20201221140358663.png)

​		本节内容仅需理解即可。

### 3.1.4 **连续分配管理方式**

- **单一连续分配：**

![image-20201222160206978](assets/image-20201222160206978.png)

​		对于单一连续分配，对适用于内存中只有一道用户程序，所以在分配内存的时候除系统区外的用户区全部分配给了用户进程。这样实现起来很简单，但是由于分配给用户的内存用户无法全部利用，所以它会有内部碎片，无外部碎片。

> ***内部碎片与外部碎片在内存中的区别：***
>
> 内部碎片就是分配内存给相应的进程后，由于分配给进程的内存比进程实际要使用的内存在，所以叫做内部碎片。内部碎片对应于已经分配完成的分区。
>
> 外部碎片是将内存分配相应的内存给进程后，其会剩余一些小的内存，以至于这些内存虽然存在，但由于太小，不能分配给其他需要内存的进程，这样就导致了外部碎片。外部碎片对应于还未分配的分区。

- **固定分区分配：**

![image-20201222160927742](assets/image-20201222160927742.png)

固定分区就见名知义。

![image-20201222161034729](assets/image-20201222161034729.png)

分区说明表见上图。

- **动态分区分配：**

![image-20201222161148509](assets/image-20201222161148509.png)

***动态分区分配使用的数据结构：***

![image-20201222161411594](assets/image-20201222161411594.png)

- **动态分区分配分析：**

![image-20201222161651188](assets/image-20201222161651188.png)

- **总结：**

![image-20201222161821668](assets/image-20201222161821668.png)

### 3.1.5 动态分区分配算法

- **首次适应算法：**

![image-20201222162019375](assets/image-20201222162019375.png)

​	其实就是按顺序寻找合适的内存。

- **最佳适应算法：**

![image-20201222162408552](assets/image-20201222162408552.png)

​	其空闲分区按容量递增的方式链接，优先使用最小的分区进行分配，但会产生大量的外部碎片。

- **最坏适应算法：**

![image-20201222162648279](assets/image-20201222162648279.png)

​	与最佳适应算法相反，其空闲分区按容量递减的方式链接，优先使用大容量的分区，但当大分区快用完时就没有办法给新的大进程分配内存了。

- **邻近适应算法：**

![image-20201222163052018](assets/image-20201222163052018.png)

​	描述见上图。

- **总结：**

![image-20201222163201236](assets/image-20201222163201236.png)

### 3.1.6 基本分页存储管理

- **思考：连续分配方式的缺点**

![image-20201222163543237](assets/image-20201222163543237.png)

基于对连续分配方式的理解，其内存的分配均是连续的内存空间，且缺点也如上图。所以提出了非连续分配方式。

- **固定分区分配的”改造“**

![image-20201222163820749](assets/image-20201222163820749.png)

- **分页存储管理基本概念：**

![image-20201222164009565](assets/image-20201222164009565.png)

对于内存，我们将其的地址空间可以分为”页框“等，其编号称为”页框号“。

对于进程，我们将其地址空间分为与页框大小相等的区域，称之为”页/页面“，其编号为”页号“。

> 注意区分”页框“与”页面“定义上的区别。另外，将页面存放到页框并不必连续存放，也不必按先后顺序来，可以将其放到不相邻的各个页框中。

- **思考：如何实现地址的转换**

![image-20201222165347529](assets/image-20201222165347529.png)

![image-20201222165441944](assets/image-20201222165441944.png)

![image-20201222165533179](assets/image-20201222165533179.png)

![image-20201222165658941](assets/image-20201222165658941.png)

![image-20201222165712369](assets/image-20201222165712369.png)

​	上述图例解释了如何将进程页面的逻辑地址转换为内存中的物理地址，过程很清晰，文字描述略。

- **逻辑地址结构：**

![image-20201222165834710](assets/image-20201222165834710.png)

​	如果知道了逻辑地址的二进制结构，那么根据其页大小很容易可以计算出一个逻辑地址的页号、偏移量。如果想要知道对应的物理地址，那么还缺少一个条件——起始地址，接下来引入页表来求得页面在内存中的起始地址。

- **页表：**

![image-20201222170300970](assets/image-20201222170300970.png)

​	根据页表可以找到每个页号对应的块号，知道了块号之后其实就已经知道了该页的起始地址（起始地址 = 块号 * 内存块大小）。那么最后一句页号是”隐含“的怎么理解呢？

![image-20201222170807484](assets/image-20201222170807484.png)

​	根据例子，每个块号均有3个字节进行表示。由于在页表中，每个页表项都是按顺序递增的排列的，一旦我们知道页表中第一项的起始地址X，那么后面的第M页的页表项的地址则为X + 3*M。也就是说在页表中不一定非要显式地将页号表示出来，这就是页号”隐含“的含义。

- **总结：**

![image-20201222171058153](assets/image-20201222171058153.png)

### 3.1.7 基本地址变换机构

- TODO

 

