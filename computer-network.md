# 计算机网络

## 1. 计算机网络概述

## 2. 物理层

## 3. 数据链路层

### 3.1 数据链路层概述

- **概述：**

![image-20201224204246449](assets/image-20201224204246449.png)

- **数据链路层的三个重要问题：**

![image-20201224204313067](assets/image-20201224204313067.png)

- **封装成帧：**

![image-20201224204342986](assets/image-20201224204342986.png)

- **差错检测：**

![image-20201224204408777](assets/image-20201224204408777.png)

![image-20201224204414400](assets/image-20201224204414400.png)

- **可靠传输：**

![image-20201224204439042](assets/image-20201224204439042.png)

> 上面的三个问题是基于点对点形式的数据链路层，如果使用广播信道的数据链路层则还会有其他问题。

- **总结：**

![image-20201224204558876](assets/image-20201224204558876.png)

### 3.2 封装成帧

- **封装成帧：**

![image-20201224204655708](assets/image-20201224204655708.png)

**思考：在数据链路层发往物理层后的比特流是如何提取帧的呢？**

![image-20201224204815901](assets/image-20201224204815901.png)

​	利用帧头和帧尾的帧定界可以对帧的比特流进行提取，以太网V2中的MAC帧并没有帧定界，但在其交付给物理层时物理层会在MAC帧的头部加一个前导码，并且还设置了帧间间隔（96比特时间），实现了帧的区分。如下图所示：

![image-20201224205141900](assets/image-20201224205141900.png)

![image-20201224205155788](assets/image-20201224205155788.png)

**透明传输：**指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。

**假设出现如下情况：**

![image-20201224205429160](assets/image-20201224205429160.png)

​	通过图中可以发现帧的数据部分出现了与帧定界标志相同字段，此时如果接收方不做任何处理，那么他能正确接收并处理该帧吗？

​	答案肯定是不可以！接收方会在收到第二个flag时误认为其是结束标志，出现错误。所以数据链路层必须对这种情况进行处理，否则它不就能成为透明传输。一般来说数据链路层对其处理的方法是在帧发送之前对帧的数据部分进行扫描，对其中的flag之前加一个转义字符（一字节），如果数据之间也存在转义字符，那就再转义字符前再加一个转义字符。接收端在接收到帧后会对转义字符进行处理。图示如下：

![image-20201224205853263](assets/image-20201224205853263.png)

![image-20201224205913864](assets/image-20201224205913864.png)

> 之前的一切都是对于面向字节的物理链路的，下面讨论一下面对比特的物理链路。

![image-20201224210306999](assets/image-20201224210306999.png)

​	面向比特的的物理链路在实现透明传输时使用的是比特填充法，它在发送时将每连续的5个比特1之后添加一个比特0，接收方对其进行反向操作即可。

- **Exercise：**

![image-20201224210538703](assets/image-20201224210538703.png)

- **帧的传输效率和MTU：**

![image-20201224210630347](assets/image-20201224210630347.png)

- **总结：**

![image-20201224210654230](assets/image-20201224210654230.png)

### 3.3 差错检测

- **概念：**

![image-20201224210757123](assets/image-20201224210757123.png)

- **奇偶校验：**

![image-20201224210823696](assets/image-20201224210823696.png)

- **CRC：**

![image-20201224210858167](assets/image-20201224210858167.png)

**举例**

![image-20201224210927613](assets/image-20201224210927613.png)

**Example：**

![image-20201224211004038](assets/image-20201224211004038.png)

> 运算是异或运算。

![image-20201224211056595](assets/image-20201224211056595.png)

- **检错码：**

![image-20201224211136065](assets/image-20201224211136065.png)

> 检错码和纠错码不同，检错码只起到检测帧在传输过程中是否出现差错，并不能定位错误和纠错。其中CRC是一种检错技术。

### 3.4 可靠传输

#### 3.4.1 可靠传输的基本概念

- **概念：**

![image-20201224211457106](assets/image-20201224211457106.png)

![image-20201224211523555](assets/image-20201224211523555.png)

①**分组丢失：**指一台主机向另一台主机发送的分组在中间过程中可能因为某个路由器的输入队列快满了而被丢弃，从而使得分组在传输过程中出现了丢失现象。

②**分组失序：**指一台主机向另一台主机以某一顺序发送多个分组，但到达目的主机时其分组并未按照一定的顺序到达，即分组失序。

③**分组重复：**指一台主机向另一台主机发送分组，但分组在传输过程中因为某些原因滞留了，这导致发送端重新发送分组到目的主机，在接收到分组后过一段时间之前滞留的分组又重新到达了目的主机，即目的主机收到了两个重复的分组，即分组重复。

![image-20201224212043497](assets/image-20201224212043497.png)

- **总结：**

![image-20201224212058954](assets/image-20201224212058954.png)

#### 3.4.2 停止-等待协议

- **停止等待协议的过程：**

![image-20201224223813690](assets/image-20201224223813690.png)

![image-20201224223839014](assets/image-20201224223839014.png)

![image-20201224223918869](assets/image-20201224223918869.png)

![image-20201224223936685](assets/image-20201224223936685.png)

![image-20201224224005195](assets/image-20201224224005195.png)

过程中的细节在[视频](https://www.bilibili.com/video/BV1c4411d7jb?p=25)中。

**对以上过程进行小结：**

![image-20201224224104765](assets/image-20201224224104765.png)

- **信道利用率：**

![image-20201224224137671](assets/image-20201224224137671.png)

![image-20201224224204833](assets/image-20201224224204833.png)

- **Exercise：**

![image-20201224224235083](assets/image-20201224224235083.png)

- **总结：**

![image-20201224224302851](assets/image-20201224224302851.png)

#### 3.4.3 回退N帧协议

- **回退N帧的提出：**

![image-20201224224431642](assets/image-20201224224431642.png)

- **过程：**

![image-20201224224729308](assets/image-20201224224729308.png)

![image-20201224224752016](assets/image-20201224224752016.png)

​	在回退N帧协议中可以用累积确认，也可以逐个发送确认。但累积确认有一个优点：即使确认分组丢失，发送方也可能不必重传。但也有缺点，就是不能向发送方及时显示出接收方接收的信息，如下：

![image-20201224225016508](assets/image-20201224225016508.png)

​	假如发送方发送多条数据分组，但接收方在接收过程中其第一个分组出现了误码，而其他分组却没有出现问题，此时由于接收窗口只有一个且只能接受第一个分组，所以后面的分组相当于直接被丢弃了，故发送方会发送多个连续的ACK4表示仅仅对4号窗口及以前的正确接收了，此时的效率会很低。

- **发送窗口只能在限定范围内：**

假如发送窗口W~T~的取值大于其范围：

![image-20201224225619703](assets/image-20201224225619703.png)

​	此时发送方的发送窗口为8，大于其给定范围。此时发送方发送8个分组，接收方在一一正确接收后向发送方发送了一个累积确认ACK7，但在传输过程中丢失了。一段时间后，发送方重传计时器超时，发送方开始超时重传，此时接收方接收到了重复分组：

![image-20201224225855392](assets/image-20201224225855392.png)

如上图，接收方无法分辨新、旧数据分组。

- **回退N帧总结：**

![image-20201224230009640](assets/image-20201224230009640.png)

- **Exercise：**

![image-20201224230039244](assets/image-20201224230039244.png)

- **总结补充：**

![image-20201224230109668](assets/image-20201224230109668.png)

#### 3.4.4 选择重传协议

- **选择重传协议的提出：**

![image-20201224230323116](assets/image-20201224230323116.png)

- **工作原理：**

![image-20201224230853457](assets/image-20201224230853457.png)

​	其工作原理和回退N帧差不多，不过选择重传协议只能对分组进行单独确认。另外，为了保证可靠传输，其接收方的窗口需要在正确接收按序到达的分组后才能滑动，所以在发送方发送过程中出现差错时，接收方只有等到相应的分组重传后才可移动滑动窗口（不严谨，具体看[视频流程](https://www.bilibili.com/video/BV1c4411d7jb?p=27)）。

- **发送方/接收方的窗口尺寸：**

![image-20201224230826190](assets/image-20201224230826190.png)

![image-20201224231012915](assets/image-20201224231012915.png)

![image-20201224231025638](assets/image-20201224231025638.png)

![image-20201224231051181](assets/image-20201224231051181.png)

​	假设发送/接收窗口超过最大值，此时发送方发送5个分组，接收方按序成功接收了所有分组，并对分组进行一一确认。但0号确认分组发送过程中出现了丢失，所以一段时间后发送方重传计时器超时，对0号分组进行重传。但其实此时接收方已经正确接收了所有分组，此时如果对收到的0号分组接收的话则会导致分组重复。**所以此时接收方无法分辨新、旧数据分组。**

- **总结：**

![image-20201224231444963](assets/image-20201224231444963.png)

- **Exercise：**

![image-20201224231521616](assets/image-20201224231521616.png)

### 3.5 PPP

- 





## 4.网络层

### 4.1 网络层概述

- **网络层概述：**![image-20201221211720739](assets/image-20201221211720739.png)
- **总结：**

![image-20201221211924927](assets/image-20201221211924927.png)

### 4.2 网络层提供的两种服务

- **面向连接的虚电路服务：**

![image-20201221212029016](assets/image-20201221212029016.png)

- **无连接的数据包服务：**

![image-20201221212106598](assets/image-20201221212106598.png)

- **总结：**

![image-20201221212134706](assets/image-20201221212134706.png)

### 4.3 IPv4

#### 4.3.1 IPv4概述

- **概述：**

![image-20201221212238612](assets/image-20201221212238612.png)

- **IPv4的表示方法（点分十进制）：**

![image-20201221212605902](assets/image-20201221212605902.png)

#### 4.3.2 分类编址的IPv4地址

- **分类编址后的IPv4类型：**

![image-20201221212712494](assets/image-20201221212712494.png)

​	从上面可以看出在分类编址中IPv4被分为了五类地址，下面对着五类地址进行详细解析。

- **A类地址：**

![image-20201221213012963](assets/image-20201221213012963.png)

​	A类地址最特殊的就是其中有两个网络号不可以指派：0/127。

- **B类地址：**

![image-20201221213219764](assets/image-20201221213219764.png)

- **C类地址：**

![image-20201221213247655](assets/image-20201221213247655.png)

- **Exercise：**

![image-20201221213332560](assets/image-20201221213332560.png)

![image-20201221213349271](assets/image-20201221213349271.png)

![image-20201221213416400](assets/image-20201221213416400.png)

#### 4.3.3 划分子网的IPv4地址

- **提出划分子网的原因：**

  ​	因为基于分类编址的IPv4地址在分配时需要根据其网络号，如果一个公司中又有多个子网，那么就需要为其他子网新增网络号，带来资源的浪费，由此产生了划分子网的IPv4地址，也就是可以通过子网掩码向主机号部分“借”网络号来使用。

![image-20201221213645987](assets/image-20201221213645987.png)

- **子网掩码：**

![image-20201221214215701](assets/image-20201221214215701.png)

- **对划分子网的IPv4进行举例：**

![image-20201221214330421](assets/image-20201221214330421.png)

![image-20201221214413500](assets/image-20201221214413500.png)

- **Exercise：**

![image-20201221214439431](assets/image-20201221214439431.png)

![image-20201221214648599](assets/image-20201221214648599.png)

- **默认子网掩码：**

![image-20201221214718724](assets/image-20201221214718724.png)

​		其实就是在分类编址的基础上对IPv4的地址进行了子网掩码的转换。

- **总结：**

![image-20201221214806086](assets/image-20201221214806086.png)

#### 4.3.4 无分类编址的IPv4地址

- **无分类编址：**

![image-20201221215503034](assets/image-20201221215503034.png)

- **CIDR：**

![image-20201221215534239](assets/image-20201221215534239.png)

- **CIDR举例：**

![image-20201221215605038](assets/image-20201221215605038.png)

- **路由聚合：**

![image-20201221215712176](assets/image-20201221215712176.png)

​		所谓路由聚合就是将几个路由表中的IP地址聚合在一起，满足其最长前缀匹配即可得到。

- **IPv4 Example：**

![image-20201221215946706](assets/image-20201221215946706.png)

> 本题很容易想当然的将能收到IP分组的主机数量表示为：总主机数 - 2。但其实本题属于一个巧合，目的地址为192.168.4.3的地址刚好是题头子网中的广播地址，所以可接受到IP分组的主机刚好给题头子网中的合法主机，即4 - 2 = 2。但如果更改题目条件使得目的地址为子网下其中一个主机的IP地址，那么其最大主机数一定始终为1。

- **路由聚合Example：**

![image-20201221220631755](assets/image-20201221220631755.png)

- **总结：**

![image-20201221220717260](assets/image-20201221220717260.png)



#### 4.3.5 IPv4地址的应用规划

- **两种子网掩码：**

![image-20201221223713933](assets/image-20201221223713933.png)

- **定长的子网掩码：**

![image-20201221223803569](assets/image-20201221223803569.png)

![image-20201221223821960](assets/image-20201221223821960.png)

![image-20201221223854269](assets/image-20201221223854269.png)

​		根据定长的子网掩码的定义，我们只能对不同的子网设置相同的子网掩码，这就要求我们需要找到子网中需要IP地址的最大值的那一组，进而定义其子网掩码。但其有一个严重的**缺点**：IP地址会出现浪费情况，因为定长的子网掩码的设计总是根据最大值而设计的，当一个子网中需要的IP数比较少时就会造成浪费。所以提出了变长的子网掩码。

- **变长的子网掩码：**

![image-20201221224629679](assets/image-20201221224629679.png)

​	由于例子与定长的子网掩码的例子相同，在变长的子网掩码中我们仅需要对不同的地址块进行分配，下面就是**地址块的分配原则：**

![image-20201221224942530](assets/image-20201221224942530.png)

根据原则，例子的分配应如下：

![image-20201221225015342](assets/image-20201221225015342.png)

- **总结：**

![image-20201221225039154](assets/image-20201221225039154.png)

### 4.4 IP数据报的发送和转发过程

- **举例：**

![image-20201222213831651](assets/image-20201222213831651.png)

![image-20201222213908368](assets/image-20201222213908368.png)

![image-20201222213958636](assets/image-20201222213958636.png)

![image-20201222214028839](assets/image-20201222214028839.png)

​	路由器转发数据报文是会将其目的地址与路由器中路由表的子网掩码相与，然后将得到的网络号与路由表中的进行对比，相同则转发，不同则丢弃。

![image-20201222214238654](assets/image-20201222214238654.png)

​	![image-20201222214424682](assets/image-20201222214424682.png)

​	之前路由器转发的都是单播的数据报文，如果路由器收到一个广播报文，那么它是不会选择转发的。因为在庞大的互联网中如果路由器对广播报文进行转发的话，那么互联网中的主机将会收到无数个广播报文，所以不会对其转发。

- **Exercise：**

![image-20201222214452868](assets/image-20201222214452868.png)

![image-20201222214516537](assets/image-20201222214516537.png)

### 4.5 静态路由的配置及其路由环路问题

- **静态路由概述：**

![image-20201222214637675](assets/image-20201222214637675.png)

- **静态路由配置举例：**

![image-20201222214713925](assets/image-20201222214713925.png)

​	上图是网络中R1和R2的初始状态。

![image-20201222214800663](assets/image-20201222214800663.png)

​	路由器R1向R2转发IP数据包时配置静态路由。R2向R1转发也类似。

- **默认路由配置：**

![image-20201222214944806](assets/image-20201222214944806.png)

​	默认路由会在目的地址为多个的时候选择配置。

- **特定主机路由：**

![image-20201222215106844](assets/image-20201222215106844.png)

​	特定主机路由一般会在网络测试或者为了一些安全性问题考虑时会用到。其配置方法见上图。在配置之后，路由器会根据最长前缀匹配原则进行转发。

- **静态路由配置错误导致的路由环路问题：**

![image-20201222215237782](assets/image-20201222215237782.png)

上图为初始正常状态下的路由配置信息。

![image-20201222215318193](assets/image-20201222215318193.png)

上图时错误配置静态路由后的路由配置信息。

![image-20201222215404612](assets/image-20201222215404612.png)

上图为其配置错误所导致的结果——路由环路。（其过程可以在默默过一遍）

- **聚合了不存在的网络导致的路由环路问题：**

![image-20201222215528250](assets/image-20201222215528250.png)

​	上图为初始状态。

![image-20201222215622382](assets/image-20201222215622382.png)

上图为转发IP数据分组到了聚合网络下不存在的网络中，导致了路由环路问题。

![image-20201222215716170](assets/image-20201222215716170.png)

​	为了解决上述问题，引出了黑洞路由的概念。一旦IP数据由路由器转发到了黑洞路由中，那么就会直接丢弃。

- **网络故障而导致路由环路：**

![image-20201222220038561](assets/image-20201222220038561.png)

​	与路由器相连的网络发生故障，路由器的路由表中自动将与其相关的记录删除，然后受到与其相关的IP数据报后就会出现套娃操作。

![image-20201222220203147](assets/image-20201222220203147.png)

​	为了解决此问题，路由器会在路由表中添加一个与故障网络有关的黑洞路由，即解决了环路问题。一旦网络故障得到了恢复，路由器会将路由表中的黑洞路由设置为失效状态，并将之前删除的路由条目加进去，以恢复正常工作，直至下一次出现故障。

- **总结：**

![image-20201222220447596](assets/image-20201222220447596.png)

### 4.6路由选择协议

#### 4.6.1 路由选择协议概述

- **静态/动态路由选择：**

![image-20201222220707991](assets/image-20201222220707991.png)

- **因特网选用的路由选择协议的主要特点：**

![image-20201222220749843](assets/image-20201222220749843.png)

- **因特网采用分层次的路由选择协议：**

![image-20201222220823286](assets/image-20201222220823286.png)

![image-20201222220837187](assets/image-20201222220837187.png)

- **常见的路由选择协议：**

![image-20201222220910808](assets/image-20201222220910808.png)

- **路由器的基本结构：**

![image-20201222221006385](assets/image-20201222221006385.png)

![image-20201222221112188](assets/image-20201222221112188.png)

- **总结：**

![image-20201222221139842](assets/image-20201222221139842.png)

#### 4.6.2 RIP

- **RIP的基本工作原理：**

![image-20201222221251464](assets/image-20201222221251464.png)

![image-20201222221335301](assets/image-20201222221335301.png)

- **举例说明RIP基本工作过程：**

![image-20201222221428624](assets/image-20201222221428624.png)

- **RIP路由条目的更新规则：**

![image-20201222221517760](assets/image-20201222221517760.png)

初始状态，路由器C向路由器D发送自己的路由表。

![image-20201222221559114](assets/image-20201222221559114.png)

在路由器D收到来自路由器C的路由表后对其进行改造，即将其下一跳全部改为C并且将距离加一（理解为路由器D可以通过路由器C来转发报文，所以下一跳全为C且举例加一）。

![image-20201222221750821](assets/image-20201222221750821.png)

路由器D根据改造后的路由表和自己的路由表进行对比：

①如果相同下一跳但距离变化了（无论变大还是变小），则代表网络拓扑结构变化了，需要更新；

②发现新的网络则添加；

③到达目的网络距离变小了，更新。

④到达目的网络距离没变但下一跳变了，添加使其等价负载均衡。

- **Exercise：**

![image-20201222222140828](assets/image-20201222222140828.png)

答案见下图

![image-20201222222155106](assets/image-20201222222155106.png)

![image-20201222222217932](assets/image-20201222222217932.png)

> 注：时刻记住在RIP协议中当距离为16时表示目的网络不可达！！！

- **坏消息传得慢：**

![image-20201222222422929](assets/image-20201222222422929.png)

​	假设路由器R1到网络N1之间出现了故障，此时R1会将路由表中与N1的距离更改为16以表示不可达。但如果此时R2的更新周期提前于R1的发送，也就是R2发送的路由表先到达R1，R1发送到R2的路由表后到达。此时R1就会被R2发来的“谣言”而误导，从而错误地认为自己到N1的距离为3。

![image-20201222222734786](assets/image-20201222222734786.png)

​	由于已经出现了“误导”现象，所以在R1的RIP更新周期到了之后它又会向R2发送路由表，R2收到后也会继续这么做，从而产生一个长达数分钟的路由环路。这就是“坏消息传得慢”问题。

- **坏消息传得慢的解决方法：**

![image-20201222223035013](assets/image-20201222223035013.png)

- **Exercise：**

![image-20201222223121993](assets/image-20201222223121993.png)

![image-20201222223232415](assets/image-20201222223232415.png)

![image-20201222223243429](assets/image-20201222223243429.png)

==这题有疑惑。==

- **总结：**

![image-20201222223316516](assets/image-20201222223316516.png)

#### 4.6.3 OSPF

- 

#### 4.6.4 BGP

- 

### 4.7 IPv4数据报的首部格式

- **首部格式：**

![image-20201223220156109](assets/image-20201223220156109.png)

![image-20201223220222102](assets/image-20201223220222102.png)

---



![image-20201223220838045](assets/image-20201223220838045.png)

> 注：首部长度的单位为4字节。由于首部长度必须是4字节的倍数，所以当首部长度部位4字节的倍数时填充字段会进行填充。

---



![image-20201223221030912](assets/image-20201223221030912.png)

![image-20201223221058324](assets/image-20201223221058324.png)

---



举例说明**首部长度字段**和总长度字段的区别和联系：

![image-20201223221157200](assets/image-20201223221157200.png)

![image-20201223221228978](assets/image-20201223221228978.png)



----

![image-20201223221357368](assets/image-20201223221357368.png)

**举例说明：**

![image-20201223221443848](assets/image-20201223221443848.png)

---

![image-20201223221538055](assets/image-20201223221538055.png)

**举例说明：**

​	加入在配置路由器的静态路由时配置错误，使得路由之间形成了路由环路，此时肯定要对其进行处理。那么生存时间TTL即可解决这一问题，IP数据包中的TTL字段在每次经过路由器转发后都会减一，当其减为0时就会被路由器丢弃，此时路由环路也就不复存在了。

----

![image-20201223221815345](assets/image-20201223221815345.png)



---

![image-20201223221928129](assets/image-20201223221928129.png)

---

![image-20201223221937433](assets/image-20201223221937433.png)

- **Exercise：**

**题目：**

![image-20201223222106657](assets/image-20201223222106657.png)

**解析：**

![image-20201223222136367](assets/image-20201223222136367.png)

![image-20201223222206337](assets/image-20201223222206337.png)

> 此题弥补了我对分片知识的盲区，也就是对IP数据报分片时需要使得其片位移量为整数，否则需要向下取整，再进而分片！

---

**题目：**

![image-20201223222332589](assets/image-20201223222332589.png)

**解答：**

![image-20201223222406019](assets/image-20201223222406019.png)

![image-20201223222442403](assets/image-20201223222442403.png)

![image-20201223222508801](assets/image-20201223222508801.png)

> 此题比较有综合性，既考察了以太网中帧的结构和IP首部结构，还要求能够看懂捕获的以太网帧的数据部分，比较有代表性。

- **总结：**

![image-20201223222721421](assets/image-20201223222721421.png)

### 4.8 ICMP

- **ICMP的目的：**

![image-20201223222839343](assets/image-20201223222839343.png)

- **ICMP差错报文的种类：**

![image-20201223222912052](assets/image-20201223222912052.png)



①**终点不可达**

![image-20201223222949172](assets/image-20201223222949172.png)

②**源点抑制**

![image-20201223223041384](assets/image-20201223223041384.png)

![image-20201223223100477](assets/image-20201223223100477.png)

③**时间超过**

![image-20201223223128703](assets/image-20201223223128703.png)

> 另外，如果终点在规定时间内不能收到数据报文的全部数据报片时，就会把已经收到的数据报片都丢弃，也会向源点发送时间超过报文。

④**参数问题**

![image-20201223223326062](assets/image-20201223223326062.png)

⑤**改变路由（重定向）：**

![image-20201223223405742](assets/image-20201223223405742.png)

- **不发送ICMP差错报告报文的情况：**

![image-20201223223439604](assets/image-20201223223439604.png)

- **ICMP询问报文：**

![image-20201223223545187](assets/image-20201223223545187.png)

- **ICMP的应用：**

![image-20201223223618054](assets/image-20201223223618054.png)

![image-20201223223633496](assets/image-20201223223633496.png)

- **思考：tracert命令的实现原理是什么？**

![image-20201223223720991](assets/image-20201223223720991.png)

![image-20201223223754413](assets/image-20201223223754413.png)

![image-20201223223812981](assets/image-20201223223812981.png)

> tracert的实现原理就是先发送一个TTL=1的ICMP请求，当报文到达第一个路由器后，其TTL=0，故第一个路由器会返回一个ICMP差错报文。那么想要知道第二个路由器即将TTL设置为2，由此类推。

- **总结：**

![image-20201223224336077](assets/image-20201223224336077.png)

### 4.9 VPN & NAT

- **VPN：**

![image-20201223224738621](assets/image-20201223224738621.png)

![image-20201223224828597](assets/image-20201223224828597.png)

- **VPN过程：**

![image-20201223225328322](assets/image-20201223225328322.png)

![image-20201223225436364](assets/image-20201223225436364.png)

- **NAT：**

![image-20201223230134391](assets/image-20201223230134391.png)

![image-20201223230447066](assets/image-20201223230447066.png)

![image-20201223230544022](assets/image-20201223230544022.png)

由于NAT路由器只有有限个全球IP地址，所以其限制了内网主机的数量，因此可以提出NAPT。

- **NAPT：**

![image-20201223230743166](assets/image-20201223230743166.png)

> 思考：外网主机是否可以首先发起通信？
>
> 不可以。因为外网主机转发数据报时，当数据报到达NAPT路由器时由于路由表中不会存在有内网主机的信息，所以不能转发成功。

- **总结：**

![image-20201223231052233](assets/image-20201223231052233.png)









## 5.传输层

### 5.1 运输层概述

![image-20201214221103473](assets/image-20201214221103473.png)

### 5.2 运输层端口号、复用、分用概念

- **端口号：**![image-20201214222703180](assets/image-20201214222703180.png)**端口号**用来区分应用层不同应用进程。其中应该了解熟知端口号的范围。

- **复用、分用：**![image-20201214222833965](assets/image-20201214222833965.png)

- 应用层常用协议所使用的熟知端口号：![image-20201214222930711](assets/image-20201214222930711.png)

### 5.3 UDP和TCP的对比

- ![image-20201214224148315](assets/image-20201214224148315.png)

- *[具体区别](https://www.bilibili.com/video/BV1c4411d7jb?p=59)*

### 5.4 TCP的流量控制

- ![image-20201214230831416](assets/image-20201214230831416.png)	TCP中流量控制发生在接受方控制发送方流量。所谓流量控制就是让发送放的发送速率不要太快，要让接受方来得及接收。

- 实现TCP的流量控制是建立在滑动窗口机制上的，下面举一个[例子](https://www.bilibili.com/video/BV1c4411d7jb?p=60)

  > TCP的流量控制是基于滑动窗口机制的，其中滑动窗口机制采用的是累计确认。

### 5.5 TCP的拥塞控制

- ![image-20201219103439096](assets/image-20201219103439096.png)

- 对于TCP的拥塞控制，主要有四种拥塞控制算法：慢开始、拥塞避免、快重传、快恢复。

  - 首先需要声明几个重要的变量：拥塞窗口cwnd、慢开始门限ssthresh、发送窗口swnd

  ![image-20201219103940075](assets/image-20201219103940075.png)

  - 上图即各变量的基本用法。[例子](https://www.bilibili.com/video/BV1c4411d7jb?p=61)中说明了慢开始和拥塞控制的基本原理，但由于互联网中可能有时会有个别保温段丢失，但实际上网络此时并未发生拥塞，此时如果触发超时重传那么将会误认为网络发生了拥塞，会使得传输效率降低，为了改善这种情况则提出了快重传算法。

  - 快重传算法就是在超时重传器结束之前完成丢失报文的重传，其原理见视频。

  - 快恢复算法就是在出现快重传之后对ssthresh进行减半处理并将cwnd=ssthresh罢了。

- ![image-20201219105341018](assets/image-20201219105341018.png)***总结如上图***

### 5.6 TCP超时重传时间的选择

-  TCP中超时重传时间RTO的选择比较复杂，因为RTO必须保证其略大于RTT（小于会导致不必要的重传，太大导致传输效率低）。然后RTT的值不是恒定不变的，所以RTO的选取比较复杂。

- ![image-20201219105020400](assets/image-20201219105020400.png)

  上图为RTO的计算公式。它是没有发生超时重传的计算方式，发生了后会：

  ![image-20201219105150043](assets/image-20201219105150043.png)

  [例子在视频后部分](https://www.bilibili.com/video/BV1c4411d7jb?p=62)

### 5.7 TCP可靠传输的实现

- TCP可靠传输的实现靠滑动窗口机制，它是以字节为单位进行传输确认。其中的过程[见视频](https://www.bilibili.com/video/BV1c4411d7jb?p=63)。

- ![image-20201219105949799](assets/image-20201219105949799.png)

  ​	由于TCP需要对数据进行按序交付给上层处理，这就导致接受方必须将接受到的数据按序接受，但发送来的数据不一定是按序到达的，那么TCP的做法就是对不按序到达的数据临时存放在接受窗口中 ，等到字节流中所缺少的字节收到后再按序交付给上层处理。

### 5.8 TCP的三次握手

- ![image-20201219111441991](assets/image-20201219111441991.png)

  ​	TCP三次握手建立连接的过程如上图。其中的SYN代表同步位，表示三报文握手的建立，在SYN=1时，报文不能发送数据；seq表示序号；ACK表示标志位，在TCP建立连接后所有的报文段中的ACK均为1；ack表示确认号，表明对上一个TCP报文的确认，值通常为上一个seq+1。

  > 观察上图可发现第三次握手中SYN不为1，这说明第三次握手时客户端可以向服务器发送数据报文，其seq=x+1。如果此报文不携带数据，则其不消耗序号，即下一次发送数据报文是seq依旧为x+1。

- **思考：为什么TCP握手是三次而不是两次或者四次？**

  答案可以在知乎找到。

- **总结：**![image-20201219112205115](assets/image-20201219112205115.png)

### 5.9 TCP四次挥手

- ![image-20201219112729587](assets/image-20201219112729587.png)

  

  ​	TCP四次挥手的过程如上图所示，其中第一次挥手的seq表明客户端最后一次发送数据的序号+1，ack表示客户端最后一次收到数据的序号+1。其他的过程与三次握手类似，不再赘述。

- **思考：为什么TCP第四次握手后还需要等待2MSL才算结束呢？**

  答案在[视频](https://www.bilibili.com/video/BV1c4411d7jb?p=65)中。

- ![image-20201219113300123](assets/image-20201219113300123.png)

  如果TCP客户进程发生了故障，为了节省服务器的资源，则必须要有一定的措施，见上图。

### 5.10 TCP报文段的首部格式

- ![image-20201219113615374](assets/image-20201219113615374.png)

- ![image-20201219113736194](assets/image-20201219113736194.png)

  ![image-20201219113918882](assets/image-20201219113918882.png)![image-20201219113933537](assets/image-20201219113933537.png)![image-20201219113946569](assets/image-20201219113946569.png)

![image-20201219114125508](assets/image-20201219114125508.png)

![image-20201219114207367](assets/image-20201219114207367.png)

![image-20201219114241724](assets/image-20201219114241724.png)

![image-20201219114257429](assets/image-20201219114257429.png)![image-20201219114305463](assets/image-20201219114305463.png)

![image-20201219114342365](assets/image-20201219114342365.png)

![image-20201219114404911](assets/image-20201219114404911.png)

![image-20201219114432847](assets/image-20201219114432847.png)

![image-20201219114453178](assets/image-20201219114453178.png)

## 6. 应用层

### 6.1 应用层概述

![image-20201219115908895](assets/image-20201219115908895.png)

### 6.2 C/S方式和P2P方式

![image-20201219120517995](assets/image-20201219120517995.png)

### 6.3 DHCP协议

- ![image-20201219140227341](assets/image-20201219140227341.png)

	​	在一个庞大的互联网中，手动的给每个计算机配置相关的IP地址、掩码、网关等是不现实的，为了解决这一问题，我们引入了DHCP。

- **DHCP的工作过程：**

  ![image-20201219152440027](assets/image-20201219152440027.png)

    [DHCP详细过程](https://www.bilibili.com/video/BV1c4411d7jb?p=69)

- **DHCP中继代理：**![image-20201219152605747](assets/image-20201219152605747.png)

  ​	上图中提到在一个交换机下的主机可不可以自动获取到IP地址等网络配置信息。答案是否定的。因为在主机发送DISCOVER报文时需要发送广播，但路由器不会转发广播报文，所以不能自动获取。如想自动获取则需要给对应的路由器配置DHCP服务器的IP地址并使之成为DHCP中继代理。

  > DHCP中继代理是很常见的，因为不可能在每一个网络上都设置一个DHCP服务器，这样会使得DHCP服务器的数量太多。

### 6.4 DNS

- ![image-20201219150947949](assets/image-20201219150947949.png)

- **域名服务器的四种类型：**![image-20201219151040799](assets/image-20201219151040799.png)

- **域名查询方法：**![image-20201219151143692](assets/image-20201219151143692.png)

- **DNS高速缓存：**![image-20201219151247132](assets/image-20201219151247132.png)

### 6.5 FTP

- **FTP的基本工作原理：**![image-20201219161119963](assets/image-20201219161119963.png)

  ![image-20201219161223107](assets/image-20201219161223107.png)

​	上面两个图分别代表FTP的主动模式和被动模式。主动模式与被动模式不同的是：在传送数据的通路中，主动模式的客户与服务端的20端口建立连接，被动模式的则是客户与服务端的随机选择的端口建立连接。

### 6.6 电子邮件SMTP

- **电子邮件：**

![image-20201220225353454](assets/image-20201220225353454.png)

- **电子邮件的发送过程：**

![image-20201220225544163](assets/image-20201220225544163.png)

​	由上图可以看出，发送方通过用户代理使用SMTP将邮件发送给发送方的邮件服务器，在发送方邮件服务器中SMTP客户使用SMTP将邮件发送给接收方的SMTP邮件服务器。至此，发送电子邮件只使用了SMTP协议。对于接收方，其与接收方的邮件服务器不可再使用SMTP协议，而是使用POP3协议或者其他接收协议。

- **SMTP的具体过程：**

![image-20201220225934602](assets/image-20201220225934602.png)

​	SMTP的具体过程作为了解即可，具体过程在[链接](https://www.bilibili.com/video/BV1c4411d7jb?p=72)。

- **电子邮件的格式：**

![image-20201220230034884](assets/image-20201220230034884.png)

- **MIME：**

![image-20201220230140547](assets/image-20201220230140547.png)

​	由于SMTP只允许传送ASCII码文本数据，对于其他的不能满足ASCII的文本数据不能传送，为了提高其扩展性提出了MIME，它可以在发送方发送数据前对其文本数据进行处理，使其文本数据变成ASCII码数据再使用SMTP进行发送。同理，接收方只不过时发送方的逆过程罢了。如下图所示：![image-20201220230524142](assets/image-20201220230524142.png)

- **POP/IMAP：**

![image-20201220230615948](assets/image-20201220230615948.png)

![image-20201220230644900](assets/image-20201220230644900.png)

- **基于万维网的电子邮件：**

![image-20201220230729844](assets/image-20201220230729844.png)

​		由上图可以比较在同一邮件服务器下的两台主机和在不同邮件服务器下的两台主机的通信。相同的即收发双方均使用HTTP协议，不同的则在收发双方使用HTTP，收发的邮件服务器之间使用SMTP。

### 6.7 万维网WWW

- **万维网的一次访问：**

![image-20201220231046702](assets/image-20201220231046702.png)

- **URL：**

![image-20201220231137031](assets/image-20201220231137031.png)

- **万维网的文档：**

  ​	就是前端三件套。

- **HTTP：**

![image-20201220231248408](assets/image-20201220231248408.png)

- **HTTP/1.0：**

![image-20201220231348164](assets/image-20201220231348164.png)

​		HTTP/1.0采用的时非持续连接的方式，即每次请求文件都需要建立一次TCP连接，时间开销比较大。

- **HTTP/1.1：**

![image-20201220231444446](assets/image-20201220231444446.png)

​		HTTP/1.1不同于HTTP/1.0，其采用了持续连接的方式，也就是说在第一次连接建立完成后不会断开连接，只要以后所请求的文件在同一个服务器上就不需要再重新建立连接。另外，它先进于1.0的还有其流水线工作方式，也就是说它可以一下发送许多个请求报文，服务器只需要接收报文后一个一个的相应报文即可，大大节省了时间！

- **HTTP的请求报文格式：**

![image-20201220231857823](assets/image-20201220231857823.png)

> 如果Connection后面时keep-alive那就表示是持续连接。

- **HTTP请求报文中的方法：**

![image-20201220232046262](assets/image-20201220232046262.png)

- **HTTP响应报文格式：**

![image-20201220232154253](assets/image-20201220232154253.png)

- **HTTP相应报文中的状态码：**

![image-20201220232205266](assets/image-20201220232205266.png)

- **Cookie：**

![image-20201220232254405](assets/image-20201220232254405.png)

- **Cookie过程：**

![image-20201220232330598](assets/image-20201220232330598.png)

- **万维网Cache和代理服务器：**

![image-20201220232447795](assets/image-20201220232447795.png)

> 代理服务器用来减少路由器之间端到端的传播时延。其过程见[视频](https://www.bilibili.com/video/BV1c4411d7jb?p=73)，不再赘述。