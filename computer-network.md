# 计算机网络

## 1. 计算机网络概述

## 2. 物理层

## 3. 数据链路层

## 4.网络层

## 5.传输层

### 5.1 运输层概述

![image-20201214221103473](assets/image-20201214221103473.png)

### 5.2 运输层端口号、复用、分用概念

- **端口号：**![image-20201214222703180](assets/image-20201214222703180.png)**端口号**用来区分应用层不同应用进程。其中应该了解熟知端口号的范围。

- **复用、分用：**![image-20201214222833965](assets/image-20201214222833965.png)

- 应用层常用协议所使用的熟知端口号：![image-20201214222930711](assets/image-20201214222930711.png)

### 5.3 UDP和TCP的对比

- ![image-20201214224148315](assets/image-20201214224148315.png)

- *[具体区别](https://www.bilibili.com/video/BV1c4411d7jb?p=59)*

### 5.4 TCP的流量控制

- ![image-20201214230831416](assets/image-20201214230831416.png)	TCP中流量控制发生在接受方控制发送方流量。所谓流量控制就是让发送放的发送速率不要太快，要让接受方来得及接收。

- 实现TCP的流量控制是建立在滑动窗口机制上的，下面举一个[例子](https://www.bilibili.com/video/BV1c4411d7jb?p=60)

  > TCP的流量控制是基于滑动窗口机制的，其中滑动窗口机制采用的是累计确认。

### 5.5 TCP的拥塞控制

- ![image-20201219103439096](assets/image-20201219103439096.png)

- 对于TCP的拥塞控制，主要有四种拥塞控制算法：慢开始、拥塞避免、快重传、快恢复。

  - 首先需要声明几个重要的变量：拥塞窗口cwnd、慢开始门限ssthresh、发送窗口swnd

  ![image-20201219103940075](assets/image-20201219103940075.png)

  - 上图即各变量的基本用法。[例子](https://www.bilibili.com/video/BV1c4411d7jb?p=61)中说明了慢开始和拥塞控制的基本原理，但由于互联网中可能有时会有个别保温段丢失，但实际上网络此时并未发生拥塞，此时如果触发超时重传那么将会误认为网络发生了拥塞，会使得传输效率降低，为了改善这种情况则提出了快重传算法。

  - 快重传算法就是在超时重传器结束之前完成丢失报文的重传，其原理见视频。

  - 快恢复算法就是在出现快重传之后对ssthresh进行减半处理并将cwnd=ssthresh罢了。

- ![image-20201219105341018](assets/image-20201219105341018.png)***总结如上图***

### 5.6 TCP超时重传时间的选择

-  TCP中超时重传时间RTO的选择比较复杂，因为RTO必须保证其略大于RTT（小于会导致不必要的重传，太大导致传输效率低）。然后RTT的值不是恒定不变的，所以RTO的选取比较复杂。

- ![image-20201219105020400](assets/image-20201219105020400.png)

  上图为RTO的计算公式。它是没有发生超时重传的计算方式，发生了后会：

  ![image-20201219105150043](assets/image-20201219105150043.png)

  [例子在视频后部分](https://www.bilibili.com/video/BV1c4411d7jb?p=62)

### 5.7 TCP可靠传输的实现

- TCP可靠传输的实现靠滑动窗口机制，它是以字节为单位进行传输确认。其中的过程[见视频](https://www.bilibili.com/video/BV1c4411d7jb?p=63)。

- ![image-20201219105949799](assets/image-20201219105949799.png)

  ​	由于TCP需要对数据进行按序交付给上层处理，这就导致接受方必须将接受到的数据按序接受，但发送来的数据不一定是按序到达的，那么TCP的做法就是对不按序到达的数据临时存放在接受窗口中 ，等到字节流中所缺少的字节收到后再按序交付给上层处理。

### 5.8 TCP的三次握手

- ![image-20201219111441991](assets/image-20201219111441991.png)

  ​	TCP三次握手建立连接的过程如上图。其中的SYN代表同步位，表示三报文握手的建立，在SYN=1时，报文不能发送数据；seq表示序号；ACK表示标志位，在TCP建立连接后所有的报文段中的ACK均为1；ack表示确认号，表明对上一个TCP报文的确认，值通常为上一个seq+1。

  > 观察上图可发现第三次握手中SYN不为1，这说明第三次握手时客户端可以向服务器发送数据报文，其seq=x+1。如果此报文不携带数据，则其不消耗序号，即下一次发送数据报文是seq依旧为x+1。

- **思考：为什么TCP握手是三次而不是两次或者四次？**

  答案可以在知乎找到。

- **总结：**![image-20201219112205115](assets/image-20201219112205115.png)

### 5.9 TCP四次挥手

- ![image-20201219112729587](assets/image-20201219112729587.png)

  

  ​	TCP四次挥手的过程如上图所示，其中第一次挥手的seq表明客户端最后一次发送数据的序号+1，ack表示客户端最后一次收到数据的序号+1。其他的过程与三次握手类似，不再赘述。

- **思考：为什么TCP第四次握手后还需要等待2MSL才算结束呢？**

  答案在[视频](https://www.bilibili.com/video/BV1c4411d7jb?p=65)中。

- ![image-20201219113300123](assets/image-20201219113300123.png)

  如果TCP客户进程发生了故障，为了节省服务器的资源，则必须要有一定的措施，见上图。

### 5.10 TCP报文段的首部格式

- ![image-20201219113615374](assets/image-20201219113615374.png)

- ![image-20201219113736194](assets/image-20201219113736194.png)

  ![image-20201219113918882](assets/image-20201219113918882.png)![image-20201219113933537](assets/image-20201219113933537.png)![image-20201219113946569](assets/image-20201219113946569.png)

![image-20201219114125508](assets/image-20201219114125508.png)

![image-20201219114207367](assets/image-20201219114207367.png)

![image-20201219114241724](assets/image-20201219114241724.png)

![image-20201219114257429](assets/image-20201219114257429.png)![image-20201219114305463](assets/image-20201219114305463.png)

![image-20201219114342365](assets/image-20201219114342365.png)

![image-20201219114404911](assets/image-20201219114404911.png)

![image-20201219114432847](assets/image-20201219114432847.png)

![image-20201219114453178](assets/image-20201219114453178.png)

## 6. 应用层

### 6.1 应用层概述

![image-20201219115908895](assets/image-20201219115908895.png)

### 6.2 C/S方式和P2P方式

![image-20201219120517995](assets/image-20201219120517995.png)

### 6.3 DHCP协议

- ![image-20201219140227341](assets/image-20201219140227341.png)

	​	在一个庞大的互联网中，手动的给每个计算机配置相关的IP地址、掩码、网关等是不现实的，为了解决这一问题，我们引入了DHCP。

- **DHCP的工作过程：**

  ![image-20201219152440027](assets/image-20201219152440027.png)

    [DHCP详细过程](https://www.bilibili.com/video/BV1c4411d7jb?p=69)

- **DHCP中继代理：**![image-20201219152605747](assets/image-20201219152605747.png)

  ​	上图中提到在一个交换机下的主机可不可以自动获取到IP地址等网络配置信息。答案是否定的。因为在主机发送DISCOVER报文时需要发送广播，但路由器不会转发广播报文，所以不能自动获取。如想自动获取则需要给对应的路由器配置DHCP服务器的IP地址并使之成为DHCP中继代理。

  > DHCP中继代理是很常见的，因为不可能在每一个网络上都设置一个DHCP服务器，这样会使得DHCP服务器的数量太多。

### 6.4 DNS

- ![image-20201219150947949](assets/image-20201219150947949.png)

- **域名服务器的四种类型：**![image-20201219151040799](assets/image-20201219151040799.png)

- **域名查询方法：**![image-20201219151143692](assets/image-20201219151143692.png)

- **DNS高速缓存：**![image-20201219151247132](assets/image-20201219151247132.png)

### 6.5 FTP

- **FTP的基本工作原理：**![image-20201219161119963](assets/image-20201219161119963.png)

  ![image-20201219161223107](assets/image-20201219161223107.png)

​	上面两个图分别代表FTP的主动模式和被动模式。主动模式与被动模式不同的是：在传送数据的通路中，主动模式的客户与服务端的20端口建立连接，被动模式的则是客户与服务端的随机选择的端口建立连接。

### 6.6 电子邮件SMTP

- **电子邮件：**

![image-20201220225353454](assets/image-20201220225353454.png)

- **电子邮件的发送过程：**

![image-20201220225544163](assets/image-20201220225544163.png)

​	由上图可以看出，发送方通过用户代理使用SMTP将邮件发送给发送方的邮件服务器，在发送方邮件服务器中SMTP客户使用SMTP将邮件发送给接收方的SMTP邮件服务器。至此，发送电子邮件只使用了SMTP协议。对于接收方，其与接收方的邮件服务器不可再使用SMTP协议，而是使用POP3协议或者其他接收协议。

- **SMTP的具体过程：**

![image-20201220225934602](assets/image-20201220225934602.png)

​	SMTP的具体过程作为了解即可，具体过程在[链接](https://www.bilibili.com/video/BV1c4411d7jb?p=72)。

- **电子邮件的格式：**

![image-20201220230034884](assets/image-20201220230034884.png)

- **MIME：**

![image-20201220230140547](assets/image-20201220230140547.png)

​	由于SMTP只允许传送ASCII码文本数据，对于其他的不能满足ASCII的文本数据不能传送，为了提高其扩展性提出了MIME，它可以在发送方发送数据前对其文本数据进行处理，使其文本数据变成ASCII码数据再使用SMTP进行发送。同理，接收方只不过时发送方的逆过程罢了。如下图所示：![image-20201220230524142](assets/image-20201220230524142.png)

- **POP/IMAP：**

![image-20201220230615948](assets/image-20201220230615948.png)

![image-20201220230644900](assets/image-20201220230644900.png)

- **基于万维网的电子邮件：**

![image-20201220230729844](assets/image-20201220230729844.png)

​		由上图可以比较在同一邮件服务器下的两台主机和在不同邮件服务器下的两台主机的通信。相同的即收发双方均使用HTTP协议，不同的则在收发双方使用HTTP，收发的邮件服务器之间使用SMTP。

### 6.7 万维网WWW

- **万维网的一次访问：**

![image-20201220231046702](assets/image-20201220231046702.png)

- **URL：**

![image-20201220231137031](assets/image-20201220231137031.png)

- **万维网的文档：**

  ​	就是前端三件套。

- **HTTP：**

![image-20201220231248408](assets/image-20201220231248408.png)

- **HTTP/1.0：**

![image-20201220231348164](assets/image-20201220231348164.png)

​		HTTP/1.0采用的时非持续连接的方式，即每次请求文件都需要建立一次TCP连接，时间开销比较大。

- **HTTP/1.1：**

![image-20201220231444446](assets/image-20201220231444446.png)

​		HTTP/1.1不同于HTTP/1.0，其采用了持续连接的方式，也就是说在第一次连接建立完成后不会断开连接，只要以后所请求的文件在同一个服务器上就不需要再重新建立连接。另外，它先进于1.0的还有其流水线工作方式，也就是说它可以一下发送许多个请求报文，服务器只需要接收报文后一个一个的相应报文即可，大大节省了时间！

- **HTTP的请求报文格式：**

![image-20201220231857823](assets/image-20201220231857823.png)

> 如果Connection后面时keep-alive那就表示是持续连接。

- **HTTP请求报文中的方法：**

![image-20201220232046262](assets/image-20201220232046262.png)

- **HTTP响应报文格式：**

![image-20201220232154253](assets/image-20201220232154253.png)

- **HTTP相应报文中的状态码：**

![image-20201220232205266](assets/image-20201220232205266.png)

- **Cookie：**

![image-20201220232254405](assets/image-20201220232254405.png)

- **Cookie过程：**

![image-20201220232330598](assets/image-20201220232330598.png)

- **万维网Cache和代理服务器：**

![image-20201220232447795](assets/image-20201220232447795.png)

> 代理服务器用来减少路由器之间端到端的传播时延。其过程见[视频](https://www.bilibili.com/video/BV1c4411d7jb?p=73)，不再赘述。